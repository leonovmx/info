---
title: "Задача 1"
author: "ЛМ"
date: "17 февраля 2015 г."
output: 
  html_document:
    toc: true
    number_sections: false
    keep_md: true
---
----------------------
*Обновлено: `r format(Sys.Date(), "%d %B %Y")`*
----------------------

Задача на анализ данных
======================
Имеются данные по 332 датчикам, измеряющим уровень загрязнения в 332 точках США.
Данные по каждому датчику хранятся в отдельном **`.csv`** файле, название которого
является ID датчика. Например, данные датчика №1 хранятся в файле **`001.csv`**.

Данные можно скачать тут: https://yadi.sk/d/nPgfPD0WejLWP

Каждый файл содержит 3 переменные:

- **`Date`**: Дата наблюдения в формате *YYYY-MM-DD*
- **`sulfate`**: уровень содержания сульфатов в воздухе (микрограммы/м^3)
- **`nitrate`**: уровень содержания нитратов в воздухе (микрограммы/м^3)

В данных могут содержаться пропуски значений (NA) для любой переменной.

Необходимо распаковать файл **specdata.zip** в созданную папку **specdata**
Далее задать в качестве рабочей директории папку, содержащую  папку **specdata**
Затем написать три функции.

  1. **`getmonitor`** --- получение данных с конкретного датчика.
  2. **`complete`** --- получение сведений о количестве полных наблюдений для заданного
   списка датчиков.
  3. **`corr`** --- получение вектора корреляций нитратов и сульфатов по всем датчикам
   для заданного порогового значения количества полных наблюдений.

Функция 2 может использовать функцию 1 и не может содержать оператор `complete.cases()`
Функция 3 может использовать функцию 1 и 2

# `getmonitor()`
```{r getmon_fun, results='hide'}
getmonitor <- function(id, directory, summarize = FALSE) {
    # Тело функции
}
```

#### Аргументы функции
- **`id`** --- вектор, обозначающий номер датчика. 
Пользователь может ввести целое число, число, число в виде символа (`1, c(1,20,50), 1:332`).

- **`directory`** --- символьная переменная длиной 1, обозначающая
место хранения таблиц данных, обычно `"specdata"`, если до этого было установлен
рабочий каталог.
  
- **`summarize`** --- логический индикатор. 
По умолчанию `FALSE` --- печать не производится.
Если `TRUE` --- производится печать сводной информации (различные статистики).

#### Вывод функции 
Функция должна возвращать данные наблюдений конктретного датчика 
в выбранной директории в формате **`data.frame()`**. При необходимости выводить
на экран сводные данные.

```{r getmon_work, echo=FALSE}
getmonitor <- function(id, directory, summarize = FALSE) {
    setwd("~/Downloads/data_frame")
    id<-as.integer(id)
    if(id<10) {id<-paste('00',id,sep='')} else {
    if(id<100) {id<-paste('0',id,sep='')}}
    path<-paste(directory,'/',id,'.csv',sep='')
    d<-read.csv(path)
    if (summarize) {print(summary(d))}
    return(d)
}
```
**Пример 1.**
```{r}
data <- getmonitor("1", "specdata")
head(data)
```
**Пример 2.**
```{r}
data <- getmonitor(101.00, "specdata", TRUE)
head(data)
```

# `complete()`

```{r}
complete <- function(directory, id = 1:332) {
    # тело функции   
}
```

#### Аргументы функции
- **`directory`** --- символьная переменная длиной 1, обозначающая место хранения таблиц данных 
- **`id`** --- целочисленный вектор, обозначающий ID используемых датчиков
  
Требуется найти количество полных наблюдений (без пропущенных, т.е. без `NA`)
в данных для контретногосписка датчиков

#### Вывод функции 
Функция должна возвращать данные в следующем виде (формат `data.frame`):
  
```{r, echo=FALSE}
complete <- function(directory, id = 1:332) {
    setwd("~/Downloads/data_frame")
    n<-length(id)
    otv<-matrix(0,nrow=n,ncol=2)
    b<-1
    for(i in id) {
        d<-getmonitor(i, "specdata")
        otv[b,]<-c(i,length(d[(!is.na(d[,'sulfate']))&(!is.na(d[,'nitrate'])),1]))
        b<-b+1
    }
  otv<-data.frame(otv)
  names(otv)<-c('id','nobs')
  return(otv)
}
```
  
**Пример 1.**
```{r, cache=TRUE}
complete("specdata", c(2, 4, 8, 10, 12))
```
**Пример 2.**
```{r, cache=TRUE}
complete("specdata", 30:25)
```
**Пример 3.**
```{r,cache=TRUE}
complete("specdata", 3)
```

# `corr()`
```{r}
    corr <- function(directory, threshold = 0) {
        # тело функции   
    }
```
#### Аргументы функции
- **`directory`** --- символьная переменная длиной 1, обозначающая место хранения таблиц данных 
- **`threshold`** --- числовой вектор длиной 1, обозначающий пороговое значение для требуемого количества полных наблюдений, необходимого для расчета корреляции между значениями нитратов и сульфатов. По умолчанию 0.

#### Вывод функции
Функция должна возвращать вектор корреляций значений нитратов и сульфатов для каждого датчика, у которого количество полных наблюдений больше или равно пороговому значению. 

Формула корреляции (линейной):
$$ cor(x,y) = \frac{\Sigma_i^n(x_i-\overline{x})(y_i-\overline{y})}
{\sqrt{\Sigma(x_i - \overline{x})^2  \Sigma(y_i - \overline{x})^2}} $$

$\overline{x}$ --- математическое ожидание. Вычисляется как арифметическое среднее 
$\overline{x} =\frac{1}{n} \Sigma_{i=1}^n (x_i)$

```{r, echo=FALSE}
corr <- function(directory, threshold = 0) {
    corr<-c()
    for (id in 1:332) {
        d<-getmonitor(id,'specdata')
        n<-complete("specdata", id)
        if((n[1,2])>=threshold) {
            data<-d[complete.cases(d),]
            a<-cor(data[,'sulfate'],data[,'nitrate'])
            corr<-c(corr,a)
        }
    }
    return(corr) 
}
```

**Пример 1.**
```{r, cache=TRUE}
cr <- corr("specdata") 
summary(cr)
length(cr)
```
**Пример 2.**
```{r, cache=TRUE}
cr <- corr("specdata", 5000)
summary(cr)
length(cr)
```

# Статистики, необходимые для выводы в функции getmonitor()

1. Среднее. Вычисляется как арифметическое среднее
2. Медиана.
    - Вычисляется как серединный элемент в отсортированном массиве.
3. Дисперсия, среднеквадратичное отклонение
    - дисперсия $D(x) = \Sigma_{i=1}^n\frac{(x_i - \overline{x})^2}{(n-1)}$
    - среднекваратичное отклонение $\sigma(x) = \sqrt{\Sigma_{i=1}^n\frac{(x_i - \overline{x})^2}{(n-1)}}$

4. Второй квартиль
    - вычисляется как медиана на интревале до медианы из п. 2
5. Третий квартиль
    - вычисляется как медиана на интревале после медианы из п. 2
6. Минимум
7. Максимум
8. Количество наблюдений, количество `NA`.

#### Корреляция
Корреляция показывает сонаправленность величин. 
Например, создадим две  величины `x` и `y` и посмотрим на графике как они распределены. Пусть `x` будет упорядочным вектором от `1901` до `2000` (это может быть переменная `Год`), а `y` просто случайная величина (распределённая по нормальному закону).
```{r}
x <- 1901:2000
y <- rnorm(100, mean = 170, sd = 20)
plot(x, y)
```

Никакой закономерности не наблюдается. Корреляция двух величин почти равна `0` (в то время как максимальное значение `1`). 

```{r}
cor(x, y)
```

Если же создать `y = x + e`, где `e` - случайная величина, то на графике можно увидеть закономерность.

```{r}
x <- 101:200
y <- 2*x + rnorm(100, mean = 170, sd = 20)
plot(x, y)
```

И корреляция будет "больше", что говорит о том, что величины двигуются "сонаправлено".
```{r}
cor(x, y)
```

К примеру можно взять более реальные данные. Возьмём дневные данные цен закрытий основных европейских торговых площадок с 1991 по 1998:

- DAX --- Deutscher Aktienindex --- фондовый индекс Германии.
- SMI --- Swiss Market Index --- швейцарский фондовый индекс.
- CAC --- Cotation Assistée en Continu --- фондовым индексом Франции.
- FTSE --- Financial Times Stock Exchange Index --- индекс Британской фондовой биржи.

```{r}
library("datasets")
cor(EuStockMarkets)
```

Корреляция всех индексов близка к `1`, что говорит о сонаправленности всех индексов, их динамика очень схожа друг с другом, что видно на графике ниже. Но важно помнить, что корреляция не коим образом не указывает на причино-следственную связь.

```{r}
plot(EuStockMarkets)
```

----------------------
*Обновлено: `r format(Sys.Date(), "%d %B %Y")`*
----------------------