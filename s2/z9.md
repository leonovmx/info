# Задача 9
ЛМ  
28 февраля 2015 г.  
----------------------
*[Главная](http://leonovmx.github.io/info/index.html) --- [Семестр 2](./index/html)*
*Обновлено: 02 мая 2015*
----------------------

Документ будет формироваться и немного меняться.

# Задачи
1. Кластеризация банков на последнюю дату (просто написать функцию, не надо 
искать оптимальное количество клатеров)
2. Динамика доли кредитов и депозитов госбанков
3. Динамика доли банков, которая предоставила отчётность
4. Список банков, которые меняли названия
# Данные

При выполнении задания рекомендую установить рабочую директорию.
В данной папке у вас должны находится скаченные документы и фалы. Это существенно упростит выполнение задания.

```r
    setwd("~/Яндекс.Диск/banks")
# ~  обозначает "домашнюю" папку
# Можно писатьи "C:/Информатика/папка/"
```
# Описание
Данные представляют собой балансы банков с 2004 года на каждый месяц по н/в. 

[Сайт ЦБ РФ](http://cbr.ru/) --- [Информация по кредитным организациям](http://cbr.ru/credit/) --- [Формы отчётности](http://cbr.ru/credit/forms.asp)

Форма 101 --- Оборотная ведомость по счетам бухгалтерского учета кредитной 
организации (А, к примеру, форма 102 --- отчёт о прибылях и убытках). 
Данная форма составляется на конкретную дату (на первое число каждого месяца 
без учета операций в этот день). Форма содержит информацию о привлечённых 
депозитах, выданных кредитах, объёмах просроченной задолженности, о кредитах, 
выданных ЦБ этой кредитной организации.

План счетов (список всех счетов и что они значат) можно посмотреть тут:

- [Документ ЦБ с планом счетами](http://www.cbr.ru/analytics/standart_acts/others/302-p.pdf)
- [Консультант + ](http://www.consultant.ru/document/cons_doc_LAW_174901/?frame=1#p71)
- [Google](https://www.google.ru/search?hl=ru&q=%D0%BF%D0%BB%D0%B0%D0%BD+%D1%81%D1%87%D0%B5%D1%82%D0%BE%D0%B2+%D0%B1%D0%B0%D0%BD%D0%BA%D0%B0&btnG=%D0%9F%D0%BE%D0%B8%D1%81%D0%BA+%D0%B2+Google&lr=&gws_rd=ssl)

## Структура

Папка на определенную дату (в зависимости от периода) содержит следующие файлы:

1. mmyyyy_B.DBF - балансы банков
2. mmyyyy_N.DBF - имена банков, которые есть в отчете в п. 1
3. mmyyyy_S.DBF - ненужный файл
4. mmyyyyB1.DBF - балансы банков
5. mmyyyyN1.DBF - имена банков, которые есть в отчете в п. 4
6. mmyyyyS1.DBF - ненужный файл
7. names.DBF - номера и названия счетов

Файлы, которые имеют "_", отличаются от других просто количеством предоставляемой информации. Если банк есть в одной файле, то его нет в другом.

Описание переменных можно взять тут: 

## Загрузка данных

Для загрузки данных формата `DBF` необходима функция `read.dbf()` из пакета
`foreign`.



```r
    setwd("~/Яндекс.Диск/banks")
    library(foreign)
    d_b <- read.dbf(file = adr, as.is = T)
    head(d_b)
```

```
##   REGN PLAN NUM_SC   ITOGO A_P         DT
## 1 1326 \x80  20309  655970   2 2015-04-01
## 2 1326 \x80  30122       2   2 2015-04-01
## 3 1326 \x80  30220 1929601   2 2015-04-01
## 4 1326 \x80  30221       0   1 2015-04-01
## 5 1326 \x80  30236 1512465   2 2015-04-01
## 6 1326 \x80  30413  286795   1 2015-04-01
```

```r
# adr - путь к файлу, текстовый тип, вида "./101-20140401/032015_B.DBF"
# параметр as.is = T указывает функции на то, чтобы она текстовые форматы 
# оставляла текстовыми, а не переделывала в факторные
```

Для получения адреса можно использовать функции `list.dirs` и `list.files`. 

1. `list.dirs(path = , recursive = )` - позволяет получить список все папок (директорий).
    - параметр `path` указывает, где надо искать папки;
    - если параметр `recursive` указан как `F`, то будут выведены, только папки, которые находят по указаному адресу в `path`, Если параметр указан как `T`, то функция будет искать папки и внутри уже найденных папок.

Пример:

```r
    setwd("~/Яндекс.Диск/banks")
    head(list.dirs(path = ".", recursive = F))
```

```
## [1] "./101-20040201" "./101-20040301" "./101-20040401" "./101-20040501"
## [5] "./101-20040601" "./101-20040701"
```

```r
# В данном случае результаты будут одинаковые для случая recursive = F и T, 
# так как папок (вложенных) больше нет
```
   
2. `list.files(path = , pattern = , recursive = , ignore.case = )` позволяет найти файлы по заданному адресу. 
    - `path` содержит путь, где надо искать файлы; 
    - в параметре `pattern` указывается шаблон искомых файлов. Например, можно указать "B.DBF$", чтобы он искал только файлы, которые заканчиваются на "B.DBF", а знак $ указывает на то, что это должен быть конец строки (более подробно о таких символах в разделе "Работа с текстом. Регулярные выражения"). 
    - параметр `recursive` указывает, надо ли искать в
имеющихся папках дальше (вглубь). 
    - `ignore.case = T` указывает, что надо игнорировать
регистр (большие и маленькие буквы).


```r
    setwd("~/Яндекс.Диск/banks")
    head(list.files(path = "." , pattern = ".DBF$", 
                    recursive = T, ignore.case = T))
```

```
## [1] "101-20040201/012004_B.DBF" "101-20040201/NAMES.DBF"   
## [3] "101-20040301/022004_B.DBF" "101-20040301/NAMES.DBF"   
## [5] "101-20040401/032004_B.DBF" "101-20040401/NAMES.DBF"
```

Данными функциями можно воспользоваться, чтобы получить список всех папок,
путем сортировки, можно найти "последнюю" папку (то есть папку на последнюю 
доступную дату). Затем можно получить список файлов, находящихся в папке. 

Данные закодированы в кодировке --866--. 
Для перекодирования необходимо применить к каждому ряду, который
является текстовым типом, функцию `iconv(x, from = "866")`. `x` - что будет 
перекодировано, `from = "866"` - из какой кодировки.

Чтобы определить тип столбца, можно вопсользоваться функцией `class`.


```r
x <- data.frame(n = c(1,2,3,4), 
                t = as.character(c(1,2,3,4)), 
                tt = c("Москва", "Питер", "Волгоград", "Севастополь"),
                stringsAsFactors = F)
sapply(X = x, FUN = class)
```

```
##           n           t          tt 
##   "numeric" "character" "character"
```

```r
sapply(X = x, FUN = class) == "character"
```

```
##     n     t    tt 
## FALSE  TRUE  TRUE
```

Данные скачать тут:
https://yadi.sk/d/7maGM8k0gPHeF



# Кластеризация

Загрузив данные на последнюю доступную дату необходимо провести 
кластеризацию банков. Для начала необходимо выбрать параметры, по которым 
будут сраниваться банки. Например: размер активов, доля депозитов ФЛ в активах,
отношение депозитов к кредитам.

Провести кластеризацию модифицрованным методом K-means. В рамках кластеризации 
определить не только принадлежность каждого банка к кластеру, но и 
определить количество кластеров.

Если выбраны номинальные показатели (размер активов, депозитов), то для уменьшения
разброса можно использовать `log(), log10()` (возможно такое, что у банка нет какого-то показателя, тогда после применения функции будет получен ответ `-Inf`). 

Если выбран показатель номинальный и доля (размер активов и доля депозитов 
относительно активов), то необходимо привести их более сравнивым показателям, то есть 
номинальыйн показатель также привести к интервалу $[0, 1]$. 

Нормировка показателя $x$ к интервалу $[a, b]$ можно сделать по формуле:
$$x_{new} = \frac{x - x_{min}}{x_{max} - x_{min}} * (b - a) + a$$

## Метод K-means

## Отрисовка

# Динамика доли государственных банков

Государственные банки - это банки, котрыми владеет государство, государственные
компании, или госудасртвенные банки. Понятие владение означает наличие доли у
владеющей компании не менее 50% акций + 1.


```r
#REGN банков, которые можно назвать госудасртвенными
gos <- c(1481, 1623, 1000, 2168, 650, 2748, 3349, 354, 2403, 2790, 1088, 3360,
         3340, 3466, 1950, 2312, 1911, 1942, 1470, 3287, 843, 2590, 708, 2306, 
         2546)
sber <- 1481
```

Необходимо собрать информацию по депозитам и кредитам в разрезе ФЛ и ЮЛ.
Найти общий объем показателей, найти объём, которые принадлежит госбанкам.
Найти доли на каждую дату.

# Приложение.

## Работа с текстом. Регулярные выражения.

Под регулярными выражениями понимаются выражения для работы с текстом. 
Иногда необходимо искать некие шаблоны (чтобы имя файлы было особенным, 
или начиналось с определённого символа) и тд.

Функции для работы с текстом:
1. `grep`, `grepl` - поиск (первая выдает позиции, вторая выдает T/F)
     - `pattern` - что искать (тут как раз и испоьзуются регулярные выражения).
     - `x` - где искать (вектор, где каждый элемент, например, название файла)
2. gsub - замена
     - `pattern` - что искать
     - `replacement` - на что заменять
     - `x` - где искать
     
Пример.
Если необходимо найти картинки (с раширением `png`).
```
# x - список всех имен файлов какой-то папке.
    grep(pattern = "\\.png$", x = x, ignore.case = T)
```

`\\.` - означает просто `.`, но просто нельзя указать, так как точка является
вспомогательным выражением (означает 1 любой символ), потому перед ней стоит `\\`.

`$` означает, что это в конце строки. `^` означает начало строки.

Подробно можно это посмотреть:

1. [Внизу таблица нужная](http://www.endmemo.com/program/R/grep.php)
2. [Инструкция из R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/regex.html)
3. [Wiki](http://en.wikibooks.org/wiki/R_Programming/Text_Processing)
4. [Интересные примеры](http://www.r-bloggers.com/regular-expressions-in-r-vs-rstudio/)
